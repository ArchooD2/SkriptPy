import importlib.util
import sys
import os
import re

from skriptpy.core import ctx
from skriptpy import __version__

# SnapArg import
from snaparg import SnapArgumentParser

def transpile_py_to_sk(input_file: str, output_file: str) -> None:
    try:
        spec = importlib.util.spec_from_file_location("script", input_file)
        if spec is None:
            raise ImportError(f"Could not load module from {input_file}")

        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        with open(output_file, "w") as f:
            f.write("# Generated by skriptpy\n\n")
            for cmd in ctx.commands:
                f.write(cmd.to_skript() + "\n\n")
            for evt in ctx.events:
                f.write(evt.to_skript() + "\n\n")
        print(f"Successfully transpiled {input_file} to {output_file}")
    except ImportError as e:
        print(f"Error importing Python module: {e}")
        sys.exit(1)
    except IOError as e:
        print(f"Error writing to output file: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected error during transpilation: {e}")
        sys.exit(1)


def transpile_sk_to_py(skript_code: str) -> str:
    lines = skript_code.splitlines()
    output = ["from skriptpy.core import *\n"]
    indent_stack = [0]

    for line in lines:
        stripped = line.strip()
        indent = len(line) - len(stripped)

        while indent < indent_stack[-1]:
            indent_stack.pop()
            output.append(" " * indent_stack[-1] + "ctx.pop()")

        if stripped.startswith("command /"):
            cmd_name = re.findall(r"command /([^:]+):", stripped)[0]
            output.append(f'@command("{cmd_name}")\ndef _():')
            indent_stack.append(indent + 4)

        elif stripped.startswith("on "):
            evt = re.findall(r"on ([^:]+):", stripped)[0]
            output.append(f'@event("{evt}")\ndef _():')
            indent_stack.append(indent + 4)

        elif stripped.startswith("trigger:"):
            continue

        elif stripped.startswith("send "):
            msg = re.findall(r'send "(.*?)"', stripped)[0]
            output.append(" " * indent_stack[-1] + f'send("{msg}")')

        elif stripped.startswith("broadcast "):
            msg = re.findall(r'broadcast "(.*?)"', stripped)[0]
            output.append(" " * indent_stack[-1] + f'broadcast("{msg}")')

        elif stripped.startswith("teleport "):
            parts = stripped.split()
            output.append(" " * indent_stack[-1] + f'teleport("{parts[1]}", "{parts[3]}")')

        elif stripped.startswith("set {"):
            m = re.match(r"set \{(.+?)::%player's uuid%\} to (.+)", stripped)
            if m:
                output.append(" " * indent_stack[-1] + f'set_var("{m[1]}", {m[2]})')
            else:
                m = re.match(r"set \{_(.+?)\} to (.+)", stripped)
                if m:
                    output.append(" " * indent_stack[-1] + f'set_local("{m[1]}", {m[2]})')

        elif stripped.startswith("if "):
            condition = stripped[3:].rstrip(":")
            output.append(" " * indent_stack[-1] + f'with If("{condition}"):')
            indent_stack.append(indent + 4)

        elif stripped.startswith("else:"):
            output.append(" " * indent_stack[-1] + "with Else():")
            indent_stack.append(indent + 4)

        elif stripped.startswith("loop "):
            if "all players" in stripped:
                output.append(" " * indent_stack[-1] + "with loop_players():")
            else:
                times = re.findall(r"loop (\d+) times", stripped)[0]
                output.append(" " * indent_stack[-1] + f"with loop_times({times}):")
            indent_stack.append(indent + 4)

    while len(indent_stack) > 1:
        indent_stack.pop()
        output.append(" " * indent_stack[-1] + "ctx.pop()")

    return "\n".join(output)


if __name__ == "__main__":
    parser = SnapArgumentParser(
        description="SkriptPy transpiler - Convert between Python and Skript files.",
        epilog="Supports both .py to .sk and .sk to .py conversions."
    )
    parser.add_argument("input_file", help="Input file (.py or .sk)")
    parser.add_argument("output_file", help="Output file destination")
    parser.add_argument("-v", "--verbose", action="store_true", help="Enable verbose output")
    parser.add_argument("--version", action="version", version=f"SkriptPy v{__version__}")

    args = parser.parse_args()
    input_file, output_file, verbose = args.input_file, args.output_file, args.verbose

    if not os.path.exists(input_file):
        print(f"Error: Input file '{input_file}' does not exist.")
        sys.exit(1)

    if verbose:
        print(f"Processing {input_file}...")

    try:
        if input_file.endswith(".py"):
            if verbose:
                print("Transpiling Python to Skript...")
            transpile_py_to_sk(input_file, output_file)
        elif input_file.endswith(".sk"):
            if verbose:
                print("Transpiling Skript to Python...")
            with open(input_file, "r") as f:
                skript_code = f.read()
            python_code = transpile_sk_to_py(skript_code)
            with open(output_file, "w") as f:
                f.write(python_code)
        else:
            print(f"Error: Unsupported input file type '{os.path.splitext(input_file)[1]}'. Must be .py or .sk")
            sys.exit(1)
    except Exception as e:
        print(f"Transpilation failed: {e}")
        sys.exit(1)

    if verbose:
        print(f"Successfully wrote output to {output_file}")
